.. _main_functions:

Main functions
==============

This page covers some of the core functions of ``MacroDensity``. It is intended to show how these functions
work *not* as an example of using them in a workflow. If you are interested in specific workflows, we suggest
that you check out the :ref:`tutorials` section of the docs.

=============
Reading tools
=============

These are the tools for reading densities from calculations.

Read VASP density
-----------------

``MacroDensity`` can read in the ``LOCPOT`` and ``CHGCAR``  file generated by `VASP <https://www.vasp.at/>`_. 
If you have ``pandas`` isntalled the reading can be a little bit quicker. If you don't specify whether or not
you want to use ``pandas``, ``MacroDensity`` will check if it is available and use it is it is. This is set by the 
``use_pandas`` tag, you can also turn on/off the famous ``MacroDensity`` BOOM message. Of course the BOOM is
highly desireable, but in some instances of high-throughput analysis, it could be unnecessary!

``read_vasp_density`` returns the density as a 1D array, the grid dimensions and the lattice.

For use with subsequent functions it is usually desireable to convert the 1D array to a grid. This is done with
the ``density_2_grid`` function.

.. code:: python

    import macrodensiy as md

    vasp_pot, NGX, NGY, NGZ, Lattice = md.read_vasp_density('LOCPOT')
    grid_potential = md.density_2_grid(vasp_pot, NGX, NGY, NGZ)

Read VASP PARCHG
----------------

``PARCHG`` files in ``VASP`` contain information about the density of a particular band. These have a slightly
different format to ``LOCPOT`` and ``CHGCAR``, in particular if a calculation is spin polarised.
    

==============
Sampling tools
==============

These are the tools for analysing densities from calculations.

Planar average
--------------

This calculates along one of the cartesian axes. For more on averaging, we suggest the excellent 
`Band engineering at interfaces: theory and numerical experiments <http://iopscience.iop.org/article/10.1088/0022-3727/31/11/002/meta>`_
as an invaluable reference. From this paper, the planar aveage is defined as 

.. math::

    \bar{f}(z) = \int f(x, y, z) dxdy

The planar average requires your grid and the dimensions of grid and the direction that you want to average in 
as input. For example to take the planar averages in the *xy* plane along the *z* direction, from a density
called ``potential``, of dimension ``[nx, ny, nz]``:

.. code:: python

    planar = planar_average(potential, nx, ny, nz, axis='z')

A plot of the planar average from the above mentioned paper is shown below.

.. image:: _images/averages.png


Macroscopic average
-------------------

This calculates the running average of the planar average. The macroscopic average is defined from the planar
average

.. math::

    \bar{\bar{f}}(z) = \frac{1}{a}\int_{z - a/2}^{z + a/2} \bar{f}{z} dz

where *a* is length of the repeating unit in the *z* direction, in the plot above one *AlAs* unit. For a
macroscopic average in a direction, we need the potential, the period (*a*) and the resolution of the grid
in that direction, e.g. in the *z* direction the resolution is *1/nz* in the potential above:

.. code:: python

    macroscopic = macroscopic_average(potential, a, 1/nz)

Volume average
--------------

This calculates the average of a density within a defined volume of voxels. As input
``volume_average`` takes:

* origin - the minimum of all three axes of the area in fractional coordinates
* cube - the magnitudes of each of the three dimensions of the volume
* grid - the density that you are investigating
* nx, ny, nz - the number of points in each direction of the grid

Eg looking at the density in a 2x2x2 cube based at the mid-point of a grid:

.. code:: python

    origin = [1./2., 1./2., 1./2.]
    cube = [2, 2, 2]
    average_in_volume, variance_in_volume = volume_average(origin, cube, potential, nx, ny, nz)

Travelling volume average
-------------------------

Sometimes you want to have the volume average at a series of points along a vector. The 
``travelling_volume_average`` function allows for this possibility. The inputs are the same
as the `Volume average`_ function, but with additional parameters ``vector`` and ``magnitude``.

* vector - a three element list with the unit vector along which you want to sample
* magnitude - a single number, the distance to sample along that vector, units of grid points

Suppose we wanted to take averages running along the (110) direction for 10 grid points:

.. code:: python

    origin = [1./2., 1./2., 1./2.]
    cube = [2, 2, 2]
    vector = [1, 1, 0]
    magnitude = 10
    average_along_line= volume_average(potential, cube, origin, vector,  nx, ny, nz, magnitude)
